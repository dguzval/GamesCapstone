<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gravity Flip Platformer (3 Staged Levels + Plate-Gated Coins + Enemies)</title>
  <style>
    html, body { margin:0; padding:0; background:#111; height:100%; overflow:hidden; }
    canvas { display:block; margin:0 auto; background:#0b0b0b; image-rendering: pixelated; }
    .hint {
      position: fixed; left: 12px; top: 10px; right: 12px;
      color: #ddd; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 14px; line-height: 1.35; opacity: 0.95; user-select: none;
    }
    .hint kbd { background:#222; border:1px solid #444; padding:2px 6px; border-radius:6px; }
    .hint b { font-weight: 700; }
  </style>
</head>
<body>
  <div class="hint">
    <div>
      <kbd>A</kbd>/<kbd>D</kbd> Move &nbsp; <kbd>Space</kbd> Jump &nbsp; <kbd>G</kbd> Flip Gravity &nbsp; <kbd>R</kbd> Restart
    </div>
    <div>
      3 staged levels. Collect <b>all coins</b> to unlock the exit (green).
      Some coins are <b>plate-gated</b>: you can only collect them once a crate is on their matching <b>pressure plate</b>.
      Enemies patrol platforms; touch = death unless you <b>stomp</b> them (from the gravity-facing side).
      Spikes (pink) + void (purple) kill you.
    </div>
  </div>
  <canvas id="c" width="960" height="540"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  function resize(){ canvas.width = 960; canvas.height = 540; }
  resize();
  addEventListener("resize", resize);

  // ===== World =====
  const TILE = 32;
  const W = 30, H = 20;

  // Tile codes
  // 0 empty, 1 solid, 2 exit, 3 spikes(solid+lethal), 4 void(lethal non-solid)
  // plates: 10/12/14 (P1/P2/P3)
  const T = {
    EMPTY: 0, SOLID: 1, EXIT: 2, SPIKE: 3, VOID: 4,
    P1: 10, P2: 12, P3: 14,
  };

  // ===== Physics =====
  let gravDir = 1; // +1 down, -1 up
  const GRAVITY = 1100;
  const MOVE_SPD = 260;
  const JUMP_SPD = 440;

  // Crates
  const CRATE_FRICTION = 0.86;

  // ===== Input =====
  const keys = new Set();
  addEventListener("keydown", (e) => {
    keys.add(e.key.toLowerCase());
    if ([" ", "arrowup", "arrowdown", "arrowleft", "arrowright"].includes(e.key)) e.preventDefault();
  }, { passive: false });
  addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  // ===== Utils =====
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function aabb(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }
  function tileRect(tx, ty){ return { x: tx*TILE, y: ty*TILE, w: TILE, h: TILE }; }
  function entPos(tx, ty, w, h){ return { x: tx*TILE + (TILE-w)/2, y: ty*TILE + (TILE-h)/2 }; }

  // ===== Game State =====
  let grid = [];
  let player = null;
  let crates = [];
  let enemies = [];
  let coins = [];

  let plateActive = { p1:false, p2:false, p3:false };
  let levelIndex = 0; // 0..2
  let dead = false;
  let win = false;

  const cam = { x:0, y:0 };
  let flipCooldown = 0;
  let dt = 0;
  let last = performance.now();

  // ===== Tile logic =====
  function inBounds(tx, ty){ return tx>=0 && ty>=0 && tx<W && ty<H; }

  function tileAt(tx, ty){
    if (!inBounds(tx,ty)) return T.SOLID;
    return grid[ty][tx];
  }

  function isSolid(code){
    return code === T.SOLID || code === T.SPIKE || code === T.P1 || code === T.P2 || code === T.P3;
  }
  function isLethalToPlayer(code){ return code === T.SPIKE || code === T.VOID; }
  function isVoid(code){ return code === T.VOID; }

  function tilesInRect(x,y,w,h){
    const x0 = Math.floor(x / TILE);
    const y0 = Math.floor(y / TILE);
    const x1 = Math.floor((x + w) / TILE);
    const y1 = Math.floor((y + h) / TILE);
    const out = [];
    for (let ty=y0; ty<=y1; ty++){
      for (let tx=x0; tx<=x1; tx++){
        const code = tileAt(tx,ty);
        if (code !== T.EMPTY) out.push({ tx, ty, code, ...tileRect(tx,ty) });
      }
    }
    return out;
  }

  // ===== Collision helpers =====
  function moveAndCollideTiles(ent){
    // X
    ent.x += ent.vx * dt;
    let tiles = tilesInRect(ent.x, ent.y, ent.w, ent.h);
    for (const t of tiles){
      if (!isSolid(t.code)) continue;
      if (aabb(ent,t)){
        if (ent.vx > 0) ent.x = t.x - ent.w;
        else if (ent.vx < 0) ent.x = t.x + t.w;
        ent.vx = 0;
      }
    }
    // Y
    ent.y += ent.vy * dt;
    tiles = tilesInRect(ent.x, ent.y, ent.w, ent.h);
    for (const t of tiles){
      if (!isSolid(t.code)) continue;
      if (aabb(ent,t)){
        if (ent.vy > 0) ent.y = t.y - ent.h;
        else if (ent.vy < 0) ent.y = t.y + t.h;
        ent.vy = 0;
      }
    }
  }

  function moveAndCollideCrates(ent){
    // crates are solid AABBs (no pushing unless player X push)
    // X
    ent.x += ent.vx * dt;
    for (const c of crates){
      if (!aabb(ent,c)) continue;
      if (ent.vx > 0) ent.x = c.x - ent.w;
      else if (ent.vx < 0) ent.x = c.x + c.w;
      ent.vx = 0;
    }
    // Y
    ent.y += ent.vy * dt;
    for (const c of crates){
      if (!aabb(ent,c)) continue;
      if (ent.vy > 0) ent.y = c.y - ent.h;
      else if (ent.vy < 0) ent.y = c.y + c.h;
      ent.vy = 0;
    }
  }

  function tryPushCrate(crateIndex, dir, amount){
    const c = crates[crateIndex];
    const oldX = c.x;
    c.x += dir * amount;

    // tiles
    let tiles = tilesInRect(c.x, c.y, c.w, c.h);
    for (const t of tiles){
      if (!isSolid(t.code)) continue;
      if (aabb(c,t)){
        c.x = oldX;
        return false;
      }
    }
    // other crates
    for (let j=0;j<crates.length;j++){
      if (j===crateIndex) continue;
      if (aabb(c, crates[j])){
        c.x = oldX;
        return false;
      }
    }
    c.vx = dir * Math.max(140, Math.abs(player.vx));
    return true;
  }

  function movePlayerWithPush(){
    // X with push
    player.x += player.vx * dt;

    // tiles in X
    let tiles = tilesInRect(player.x, player.y, player.w, player.h);
    for (const t of tiles){
      if (!isSolid(t.code)) continue;
      if (aabb(player,t)){
        if (player.vx > 0) player.x = t.x - player.w;
        else if (player.vx < 0) player.x = t.x + t.w;
        player.vx = 0;
      }
    }

    // crates in X with push
    for (let i=0;i<crates.length;i++){
      const c = crates[i];
      if (!aabb(player,c)) continue;

      const pxCenter = player.x + player.w/2;
      const cxCenter = c.x + c.w/2;
      const realDir = (player.vx !== 0) ? (player.vx > 0 ? 1 : -1) : (pxCenter < cxCenter ? -1 : 1);

      const overlap = (realDir > 0) ? (player.x + player.w) - c.x : (c.x + c.w) - player.x;
      const pushAmt = overlap + 1;

      const pushed = tryPushCrate(i, realDir, pushAmt);
      if (pushed){
        if (realDir > 0) player.x = c.x - player.w;
        else player.x = c.x + c.w;
      } else {
        if (realDir > 0) player.x = c.x - player.w;
        else player.x = c.x + c.w;
        player.vx = 0;
      }
    }

    // Y (no push)
    player.y += player.vy * dt;

    tiles = tilesInRect(player.x, player.y, player.w, player.h);
    for (const t of tiles){
      if (!isSolid(t.code)) continue;
      if (aabb(player,t)){
        if (player.vy > 0) player.y = t.y - player.h;
        else if (player.vy < 0) player.y = t.y + t.h;
        player.vy = 0;
      }
    }

    for (const c of crates){
      if (!aabb(player,c)) continue;
      if (player.vy > 0) player.y = c.y - player.h;
      else if (player.vy < 0) player.y = c.y + c.h;
      player.vy = 0;
    }
  }

  function grounded(ent){
    const probeY = (gravDir === 1) ? (ent.y + ent.h + 1) : (ent.y - 1);
    if (tilesInRect(ent.x, probeY, ent.w, 1).some(t => isSolid(t.code))) return true;
    const probe = { x: ent.x, y: probeY, w: ent.w, h: 1 };
    for (const c of crates){
      if (aabb(probe, c)) return true;
    }
    return false;
  }

  function touchingLethal(ent){
    const tiles = tilesInRect(ent.x, ent.y, ent.w, ent.h);
    return tiles.some(t => isLethalToPlayer(t.code));
  }

  // ===== Plates =====
  function updatePlates(){
    // Plates are SOLID tiles, so crates won't overlap them.
    // A plate is active if a crate is pressing against it on the gravity-facing side.
    plateActive.p1 = false; plateActive.p2 = false; plateActive.p3 = false;

    for (const c of crates){
      // Sample points along crate width for robust detection.
      const sampleXs = [c.x + 2, c.x + c.w/2, c.x + c.w - 2];

      // Just beyond the crate in the current gravity direction.
      const contactY = (gravDir === 1) ? (c.y + c.h + 1) : (c.y - 1);

      for (const sx of sampleXs){
        const tx = Math.floor(sx / TILE);
        const ty = Math.floor(contactY / TILE);
        if (!inBounds(tx, ty)) continue;

        const raw = grid[ty][tx];
        if (raw === T.P1) plateActive.p1 = true;
        if (raw === T.P2) plateActive.p2 = true;
        if (raw === T.P3) plateActive.p3 = true;
      }
    }
  }

  // ===== Enemies =====
  function enemyAI(e, eGravDir){
    const aheadX = e.x + (e.vx > 0 ? e.w + 2 : -2);
    const wallProbe = tilesInRect(aheadX, e.y + 2, 2, e.h - 4).some(t => isSolid(t.code));
    if (wallProbe) e.vx *= -1;

    const frontX = e.x + (e.vx > 0 ? e.w - 4 : 4);
    const probeY = (eGravDir === 1) ? (e.y + e.h + 2) : (e.y - 2);
    const hasSupport = tilesInRect(frontX, probeY, 4, 2).some(t => isSolid(t.code));
    if (!hasSupport) e.vx *= -1;
  }

  function stompedEnemy(e){
    const margin = 6;
    if (gravDir === 1) {
      return player.vy > 0 && (player.y + player.h) <= (e.y + margin);
    } else {
      return player.vy < 0 && player.y >= (e.y + e.h - margin);
    }
  }

  // ===== Coins / Exit =====
  function gateActiveForCoin(gateId){
    if (!gateId) return true; // ungated
    if (gateId === 1) return plateActive.p1;
    if (gateId === 2) return plateActive.p2;
    if (gateId === 3) return plateActive.p3;
    return false;
  }

  function collectCoins(){
    for (const c of coins){
      if (c.collected) continue;
      if (!gateActiveForCoin(c.gate)) continue; // plate-gated
      if (aabb(player, c)) c.collected = true;
    }
  }

  function allCoinsCollected(){
    return coins.every(c => c.collected);
  }

  function atExit(){
    if (!allCoinsCollected()) return false;
    const tiles = tilesInRect(player.x, player.y, player.w, player.h);
    return tiles.some(t => t.code === T.EXIT);
  }

  // ===== Level building =====
  function makeEmptyGrid(){
    const g = [];
    for (let y=0;y<H;y++){
      const row = [];
      for (let x=0;x<W;x++) row.push(T.EMPTY);
      g.push(row);
    }
    return g;
  }
  function setTile(g,x,y,code){ if (x>=0&&y>=0&&x<W&&y<H) g[y][x]=code; }
  function stamp(g,x0,y0,w,h,code){
    for (let y=y0;y<y0+h;y++) for (let x=x0;x<x0+w;x++) setTile(g,x,y,code);
  }
  function borderAndFloor(g){
    stamp(g,0,0,W,1,T.SOLID);
    stamp(g,0,H-1,W,1,T.SOLID);
    stamp(g,0,0,1,H,T.SOLID);
    stamp(g,W-1,0,1,H,T.SOLID);
    stamp(g,1,H-2,W-2,1,T.SOLID);
  }

  function buildLevel1(){
    const g = makeEmptyGrid();
    borderAndFloor(g);

    // Platforms / hazards (similar vibe to earlier procedural)
    stamp(g, 6, H-6, 6, 1, T.SOLID);
    stamp(g, 16, H-8, 6, 1, T.SOLID);
    stamp(g, 10, 3, 7, 1, T.SOLID); // ceiling-ish route
    stamp(g, 12, H-2, 4, 1, T.VOID); // void pit
    stamp(g, 17, H-9, 3, 1, T.SPIKE); // spikes on platform

    // Plate 1 on ceiling
    setTile(g, 8, 2, T.P1);

    // Exit
    setTile(g, 27, H-3, T.EXIT);

    const playerT = { x: 3, y: H-3 };
    const crateT = [{ x: 8, y: H-3 }];

    // 3 coins total; 1 gated by P1
    const coinT = [
      { x: 7,  y: H-7, gate: 0 }, // free coin on platform
      { x: 20, y: H-9, gate: 0 }, // free coin near spikes (careful)
      { x: 23, y: H-3, gate: 1 }, // gated coin (must activate P1)
    ];

    const enemyT = [
      { x: 6, y: H-7, boots: false },
      { x: 17, y: H-9, boots: true },
    ];

    return { g, playerT, crateT, coinT, enemyT };
  }

  function buildLevel2(){
    const g = makeEmptyGrid();
    borderAndFloor(g);

    stamp(g, 5, H-6, 7, 1, T.SOLID);
    stamp(g, 14, H-9, 7, 1, T.SOLID);
    stamp(g, 20, 4, 7, 1, T.SOLID); // ceiling route
    stamp(g, 9, H-2, 3, 1, T.VOID);
    stamp(g, 24, H-2, 2, 1, T.VOID);
    stamp(g, 15, H-10, 3, 1, T.SPIKE);

    // Plates
    setTile(g, 7, 2, T.P1);
    // Nook for P2
    stamp(g, 17, H-6, 5, 1, T.SOLID);
    stamp(g, 17, H-5, 1, 2, T.SOLID);
    stamp(g, 21, H-5, 1, 2, T.SOLID);
    setTile(g, 19, H-5, T.P2);

    setTile(g, 27, H-3, T.EXIT);

    const playerT = { x: 3, y: H-3 };
    const crateT = [
      { x: 7, y: H-3 },
      { x: 15, y: H-3 },
    ];

    // 4 coins; 2 are gated (P1/P2)
    const coinT = [
      { x: 8,  y: H-7, gate: 0 }, // free
      { x: 19, y: H-10, gate: 0 },// free near spikes
      { x: 14, y: H-3, gate: 1 }, // gated by P1
      { x: 24, y: H-3, gate: 2 }, // gated by P2
    ];

    const enemyT = [
      { x: 6,  y: H-7, boots: false },
      { x: 15, y: H-10, boots: false },
      { x: 20, y: 5, boots: true },
    ];

    return { g, playerT, crateT, coinT, enemyT };
  }

  function buildLevel3(){
    const g = makeEmptyGrid();
    borderAndFloor(g);

    stamp(g, 4, H-6, 8, 1, T.SOLID);
    stamp(g, 13, H-8, 6, 1, T.SOLID);
    stamp(g, 21, H-10, 7, 1, T.SOLID);

    stamp(g, 6, 3, 6, 1, T.SOLID);
    stamp(g, 16, 4, 6, 1, T.SOLID);
    stamp(g, 24, 5, 4, 1, T.SOLID);

    stamp(g, 10, H-2, 3, 1, T.VOID);
    stamp(g, 18, H-2, 3, 1, T.VOID);
    stamp(g, 25, H-11, 2, 1, T.SPIKE);
    stamp(g, 14, H-9, 3, 1, T.SPIKE);

    // Plates
    setTile(g, 8, 2, T.P1);

    // Chamber with a hole for P2
    stamp(g, 14, H-7, 5, 1, T.SOLID);
    setTile(g, 16, H-7, T.EMPTY); // hole
    stamp(g, 14, H-6, 1, 3, T.SOLID);
    stamp(g, 18, H-6, 1, 3, T.SOLID);
    setTile(g, 16, H-3, T.P2);

    // Plate 3 on upper route
    setTile(g, 24, 6, T.P3);

    setTile(g, 27, H-3, T.EXIT);

    const playerT = { x: 3, y: H-3 };
    const crateT = [
      { x: 8,  y: H-3 },
      { x: 15, y: H-3 },
      { x: 23, y: H-3 },
    ];

    // 5 coins; 3 gated (P1/P2/P3)
    const coinT = [
      { x: 6,  y: H-7, gate: 0 }, // free
      { x: 12, y: H-9, gate: 0 }, // free near spikes
      { x: 13, y: H-3, gate: 1 }, // gated by P1
      { x: 21, y: H-3, gate: 2 }, // gated by P2
      { x: 27, y: 6,  gate: 3 }, // gated by P3 (upper)
    ];

    const enemyT = [
      { x: 5,  y: H-7, boots: false },
      { x: 13, y: H-9, boots: false },
      { x: 22, y: H-11, boots: true },
      { x: 24, y: 6, boots: false },
    ];

    return { g, playerT, crateT, coinT, enemyT };
  }

  const builders = [buildLevel1, buildLevel2, buildLevel3];

  function loadLevel(i){
    levelIndex = i;
    const data = builders[i]();

    grid = data.g;
    plateActive = { p1:false, p2:false, p3:false };
    dead = false;
    win = false;
    gravDir = 1;
    flipCooldown = 0;

    const p0 = entPos(data.playerT.x, data.playerT.y, 24, 24);
    player = { ...p0, w:24, h:24, vx:0, vy:0, grounded:false };

    crates = data.crateT.map(t => {
      const c0 = entPos(t.x, t.y, 24, 24);
      return { ...c0, w:24, h:24, vx:0, vy:0 };
    });

    coins = data.coinT.map((t, idx) => {
      const c0 = entPos(t.x, t.y, 12, 12);
      return { ...c0, w:12, h:12, collected:false, gate:t.gate || 0, idx };
    });

    enemies = data.enemyT.map((t, k) => {
      const e0 = entPos(t.x, t.y, 24, 24);
      const speed = 110 + i*30;
      const dir = (k % 2 === 0) ? 1 : -1;
      return { ...e0, w:24, h:24, vx:speed*dir, vy:0, alive:true, boots: !!t.boots };
    });

    updatePlates();
  }

  function restartGame(){ loadLevel(0); }
  function nextLevel(){
    if (levelIndex < 2) loadLevel(levelIndex + 1);
    else win = true;
  }

  // Start
  loadLevel(0);

  function nudgeAfterFlip(){
    player.y += 2*gravDir;
    for (const c of crates) c.y += 2*gravDir;
    for (const e of enemies) e.y += 2*gravDir;
  }

  function update(){
    const now = performance.now();
    dt = Math.min(0.033, (now - last)/1000);
    last = now;

    if (keys.has("r")) restartGame();

    if (!dead && !win){
      // Flip gravity
      flipCooldown = Math.max(0, flipCooldown - dt);
      if (keys.has("g") && flipCooldown === 0){
        gravDir *= -1;
        flipCooldown = 0.25;
        nudgeAfterFlip();
      }

      // Player
      let move = 0;
      if (keys.has("a")) move -= 1;
      if (keys.has("d")) move += 1;
      player.vx = move * MOVE_SPD;

      player.vy += gravDir * GRAVITY * dt;

      player.grounded = grounded(player);
      if (keys.has(" ") && player.grounded){
        player.vy = -gravDir * JUMP_SPD;
      }

      movePlayerWithPush();

      if (touchingLethal(player)) dead = true;

      // Crates
      for (let i=0;i<crates.length;i++){
        const c = crates[i];
        c.vy += gravDir * GRAVITY * dt;
        c.vx *= CRATE_FRICTION;

        moveAndCollideTiles(c);

        // collide other crates (light)
        for (let j=0;j<crates.length;j++){
          if (j===i) continue;
          const o = crates[j];
          if (!aabb(c,o)) continue;
          if (c.vx > 0) c.x = o.x - c.w;
          else if (c.vx < 0) c.x = o.x + o.w;
          c.vx = 0;
          if (c.vy > 0) c.y = o.y - c.h;
          else if (c.vy < 0) c.y = o.y + o.h;
          c.vy = 0;
        }
      }

      updatePlates();

      // Enemies
      for (const e of enemies){
        if (!e.alive) continue;

        const eGravDir = e.boots ? 1 : gravDir;
        e.vy += eGravDir * GRAVITY * dt;

        enemyAI(e, eGravDir);

        moveAndCollideTiles(e);
        moveAndCollideCrates(e);

        // Void removes enemy (spike-invulnerable)
        const tiles = tilesInRect(e.x, e.y, e.w, e.h);
        if (tiles.some(t => isVoid(t.code))) e.alive = false;

        if (aabb(player, e)) {
          if (stompedEnemy(e)) {
            e.alive = false;
            const bounce = 320;
            player.vy = -gravDir * bounce;
          } else {
            dead = true;
          }
        }
      }

      // Coins (gated by plates)
      collectCoins();

      // Exit
      if (atExit()) nextLevel();

      // Out of world
      if (player.y < -300 || player.y > H*TILE + 300) dead = true;

      cam.x = clamp(player.x + player.w/2 - canvas.width/2, 0, W*TILE - canvas.width);
      cam.y = clamp(player.y + player.h/2 - canvas.height/2, 0, H*TILE - canvas.height);
    }

    draw();
    requestAnimationFrame(update);
  }

  // ===== Render =====
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.translate(-cam.x, -cam.y);

    for (let y=0;y<H;y++){
      for (let x=0;x<W;x++){
        const raw = grid[y][x];
        if (raw === T.EMPTY) continue;

        if (raw === T.SOLID){
          ctx.fillStyle = "#2a2a2a";
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        } else if (raw === T.SPIKE){
          ctx.fillStyle = "#ff5ca8";
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
          ctx.fillStyle = "rgba(0,0,0,0.35)";
          ctx.fillRect(x*TILE+6, y*TILE+6, TILE-12, TILE-12);
        } else if (raw === T.VOID){
          ctx.fillStyle = "#7a3cff";
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        } else if (raw === T.EXIT){
          const unlocked = allCoinsCollected();
          ctx.fillStyle = unlocked ? "#2ce36b" : "#3a3a3a";
          ctx.fillRect(x*TILE+6, y*TILE+6, TILE-12, TILE-12);
        } else if (raw === T.P1 || raw === T.P2 || raw === T.P3){
          const on = (raw===T.P1 && plateActive.p1) || (raw===T.P2 && plateActive.p2) || (raw===T.P3 && plateActive.p3);
          ctx.fillStyle = on ? "#39d98a" : "#9aa0a6";
          ctx.fillRect(x*TILE+6, y*TILE+12, TILE-12, TILE-18);
          ctx.fillStyle = "rgba(0,0,0,0.35)";
          ctx.fillRect(x*TILE+8, y*TILE+14, TILE-16, TILE-22);
        }
      }
    }

    // Coins: grey if gated and inactive, yellow if available, disappear when collected
    for (const c of coins){
      if (c.collected) continue;
      const active = gateActiveForCoin(c.gate);
      ctx.fillStyle = active ? "#ffd84a" : "#7a7a7a";
      ctx.fillRect(c.x, c.y, c.w, c.h);
    }

    // Crates
    for (const c of crates){
      ctx.fillStyle = "#b37a3c";
      ctx.fillRect(c.x, c.y, c.w, c.h);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(c.x+4, c.y+4, c.w-8, c.h-8);
    }

    // Enemies
    for (const e of enemies){
      if (!e.alive) continue;
      ctx.fillStyle = e.boots ? "#ff9f2a" : "#e34b4b";
      ctx.fillRect(e.x, e.y, e.w, e.h);
    }

    // Player
    ctx.fillStyle = "#4aa3ff";
    ctx.fillRect(player.x, player.y, player.w, player.h);

    ctx.restore();

    // HUD
    ctx.fillStyle = "#ddd";
    ctx.font = "16px system-ui, sans-serif";
    const collected = coins.filter(c => c.collected).length;
    const total = coins.length;
    const unlocked = allCoinsCollected();
    ctx.fillText(
      `Level: ${levelIndex+1}/3   Gravity: ${gravDir===1?"DOWN":"UP"}   Plates: ${plateActive.p1?"1":"-"}${plateActive.p2?"2":"-"}${plateActive.p3?"3":"-"}   Coins: ${collected}/${total}   Exit: ${unlocked ? "UNLOCKED" : "LOCKED"}`,
      14, canvas.height - 16
    );

    if (dead || win){
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "#fff";
      ctx.font = "42px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(dead ? "YOU DIED" : "YOU WIN", canvas.width/2, canvas.height/2 - 10);
      ctx.font = "18px system-ui, sans-serif";
      ctx.fillText("Press R to restart", canvas.width/2, canvas.height/2 + 28);
      ctx.textAlign = "left";
    }
  }

  requestAnimationFrame(update);
})();
</script>
</body>
</html>
